/* File: keyboard.c
 * This file contains the fundamental keyboard functions
 * function keyboardhandler
 * function keyhandler
 * function isr30
 * function keyboard_init
 * Created: 2001-11-13 Markus Svensson
 * Modified:
 * # 1.001  2001-11-29 Markus Svensson
 * # 1.002  2001-11-29 Markus Svensson	Remarkes code with no use
 * # 1.003  2001-11-29 Markus Svensson	Fix so the isr30
 */

#include <conio.h>
#include <keyboard.h>
#include <pic.h>
#include <idt.h>

unsigned int buffer[BUFFER_SIZE];		// The buffer that contains all pressed keys
int p_buffer=0;					// Pointer in the buffer if 0 indicates an empty buffer
unsigned char control_keys = 0;			// Indicates which control keys ( ALT, SHIFT, CTRL ) are pressed

// # 1.002
//unsigned int *p_scan2ascii_table;		
// # 1.002

/* Table with diffrent combinations of keys pressed 
 * Converts scancodes ( code from the keyboard ) to ascii 
 * The table is copied from GazOS (gaz@athene.co.uk)
 */
unsigned int scan2ascii_table[][8] = {
/* 	ASCII -	Shift - Ctrl - 	Alt - 	Num - 	Caps - 	Shift Caps - 	Shift Num */
{  	0,	0,	0,	0,	0,	0,	0,		0},
{	0x1B,	0x1B,	0x1B,	0,	0x1B,	0x1B,	0x1B,		0x1B}, 
/* 1 -> 9 */
{	0x31,	0x21,	0,	0x7800,	0x31,	0x31,	0x21,		0x21},
{	0x32,	0x40,	0x0300,	0x7900,	0x32,	0x32,	0x40,		0x40},
{	0x33,	0x23,	0,	0x7A00, 0x33,	0x33,	0x23,		0x23},
{	0x34,	0x24,	0,	0x7B00, 0x34,	0x34,	0x24,		0x24},
{	0x35,	0x25,	0,	0x7C00,	0x35,	0x35,	0x25,		0x25},
{	0x36,	0x5E,	0x1E,	0x7D00, 0x36,	0x36,	0x5E,		0x5E},
{	0x37,	0x26,	0,	0x7E00,	0x37,	0x37,	0x26,		0x26},
{	0x38,	0x2A,	0,	0x7F00, 0x38,	0x38,	0x2A,		0x2A},
{	0x39,	0x28,	0,	0x8000, 0x39,	0x39,	0x28,		0x28},
{	0x30,	0x29,	0,	0x8100,	0x30,	0x30,	0x29,		0x29},
/* -, =, Bksp, Tab */
{	0x2D,	0x5F,	0x1F,	0x8200,	0x2D,	0x2D,	0x5F,		0x5F},
{	0x3D,	0x2B,	0,	0x8300,	0x3D,	0x3D,	0x2B,		0x2B},
{	0x08,	0x08,	0x7F,	0,	0x08,	0x08,	0x08,		0x08},
{	0x09,	0x0F00,	0,	0,	0x09,	0x09,	0x0F00,		0x0F00},  
/*	QWERTYUIOP[] */
{	0x71,	0x51,	0x11,	0x1000,	0x71,	0x51,	0x71,		0x51},
{	0x77,	0x57,	0x17,	0x1100,	0x77,	0x57,	0x77,		0x57},
{	0x65,	0x45,	0x05,	0x1200,	0x65,	0x45,	0x65,		0x45},
{	0x72,	0x52,	0x12,	0x1300,	0x72,	0x52,	0x72,		0x52},
{	0x74,	0x54,	0x14,	0x1400,	0x74,	0x54,	0x74,		0x54},
{	0x79,	0x59,	0x19,	0x1500,	0x79,	0x59,	0x79,		0x59},
{	0x75,	0x55,	0x15,	0x1600,	0x75,	0x55,	0x75,		0x55},
{	0x69,	0x49,	0x09,	0x1700,	0x69,	0x49,	0x69,		0x49},
{	0x6F,	0x4F,	0x0F,	0x1800,	0x6F,	0x4F,	0x6F,		0x4F},
{	0x70,	0x50,	0x10,	0x1900,	0x70,	0x50,	0x70,		0x50},
{	0x5B,	0x7B,	0x1B,	0x0,	0x5B,	0x5B,	0x7B,		0x7B},
{	0x5D,	0x7D,	0x1D,	0,	0x5D,	0x5D,	0x7D,		0x7D}, 
/* ENTER, CTRL */
{	0x0A,	0x0A,	0x0D,	0,	0x0A,	0x0A,	0x0D,		0x0D},
{	0,	0,	0,	0,	0,	0,	0,		0},  
/* ASDFGHJKL;'~ */
{	0x61,	0x41,	0x01,	0x1E00,	0x61,	0x41,	0x61,		0x41},
{	0x73,	0x53,	0x13,	0x1F00,	0x73,	0x53,	0x73,		0x53},
{	0x64,	0x44,	0x04,	0x2000,	0x64,	0x44,	0x64,		0x44},
{	0x66,	0x46,	0x06,	0x2100,	0x66,	0x46,	0x66,		0x46},
{	0x67,	0x47,	0x07,	0x2200,	0x67,	0x47,	0x67,		0x47},
{	0x68,	0x48,	0x08,	0x2300,	0x68,	0x48,	0x68,		0x48},
{	0x6A,	0x4A,	0x0A,	0x2400,	0x6A,	0x4A,	0x6A,		0x4A},
{	0x6B,	0x4B,	0x0B,	0x3500,	0x6B,	0x4B,	0x6B,		0x4B},
{	0x6C,	0x4C,	0x0C,	0x2600,	0x6C,	0x4C,	0x6C,		0x4C},
{	0x3B,	0x3A,	0,	0,	0x3B,	0x3B,	0x3A,		0x3A},
{	0x27,	0x22,	0,	0,	0x27,	0x27,	0x22,		0x22},
{	0x60,	0x7E,	0,	0,	0x60,	0x60,	0x7E,		0x7E},
/* Left Shift*/
{	0x2A,	0,	0,	0,	0,	0,	0,		0},

/* \ZXCVBNM,./ */
{	0x5C,	0x7C,	0x1C,	0,	0x5C,	0x5C,	0x7C,		0x7C},
{	0x7A,	0x5A,	0x1A,	0x2C00,	0x7A,	0x5A,	0x7A,		0x5A},
{	0x78,	0x58,	0x18,	0x2D00,	0x78,	0x58,	0x78,		0x58},
{	0x63,	0x43,	0x03,	0x2E00,	0x63,	0x43,	0x63,		0x43},
{	0x76,	0x56,	0x16,	0x2F00,	0x76,	0x56,	0x76,		0x56},
{	0x62,	0x42,	0x02,	0x3000,	0x62,	0x42,	0x62,		0x42},
{	0x6E,	0x4E,	0x0E,	0x3100,	0x6E,	0x4E,	0x6E,		0x4E},
{	0x6D,	0x4D,	0x0D,	0x3200,	0x6D,	0x4D,	0x6D,		0x4D},
{	0x2C,	0x3C,	0,	0,	0x2C,	0x2C,	0x3C,		0x3C},
{	0x2E,	0x3E,	0,	0,	0x2E,	0x2E,	0x3E,		0x3E},
{	0x2F,	0x3F,	0,	0,	0x2F,	0x2F,	0x3F,		0x3F}, 
/* Right Shift */
{	0,	0,	0,	0,	0,	0,	0,		0},
/* Print Screen */
{	0,	0,	0,	0,	0,	0,	0,		0},
/* Alt  */
{	0,	0,	0,	0,	0,	0,	0,		0},
/* Space */
{	0x20,	0x20,	0x20,	0,	0x20,	0x20,	0x20,		0x20},
/* Caps */
{	0,	0,	0,	0,	0,	0,	0,		0},
/* F1-F10 */
{	0x3B00,	0x5400,	0x5E00,	0x6800,	0x3B00,	0x3B00,	0x5400,		0x5400},
{	0x3C00,	0x5500,	0x5F00,	0x6900,	0x3C00,	0x3C00,	0x5500,		0x5500},
{	0x3D00,	0x5600,	0x6000,	0x6A00,	0x3D00,	0x3D00,	0x5600,		0x5600},
{	0x3E00,	0x5700,	0x6100,	0x6B00,	0x3E00,	0x3E00,	0x5700,		0x5700},
{	0x3F00,	0x5800,	0x6200,	0x6C00,	0x3F00,	0x3F00,	0x5800,		0x5800},
{	0x4000,	0x5900,	0x6300,	0x6D00,	0x4000,	0x4000,	0x5900,		0x5900},
{	0x4100,	0x5A00,	0x6400,	0x6E00,	0x4100,	0x4100,	0x5A00,		0x5A00},
{	0x4200,	0x5B00,	0x6500,	0x6F00,	0x4200,	0x4200,	0x5B00,		0x5B00},
{	0x4300,	0x5C00,	0x6600,	0x7000,	0x4300,	0x4300,	0x5C00,		0x5C00},
{	0x4400,	0x5D00,	0x6700,	0x7100,	0x4400,	0x4400,	0x5D00,		0x5D00},
/* Num Lock, Scrl Lock */
{	0,	0,	0,	0,	0,	0,	0,		0},
{	0,	0,	0,	0,	0,	0,	0,		0},  
/* HOME, Up, Pgup, -kpad, left, center, right, +keypad, end, down, pgdn, ins, del */
{	0x4700,	0x37,	0x7700,	0,	0x37,	0x4700,	0x37,		0x4700},
{	0x4800,	0x38,	0,	0,	0x38,	0x4800,	0x38,		0x4800},
{	0x4900,	0x39,	0x8400,	0,	0x39,	0x4900,	0x39,		0x4900},
{	0x2D,	0x2D,	0,	0,	0x2D,	0x2D,	0x2D,		0x2D},
{	0x4B00,	0x34,	0x7300,	0,	0x34,	0x4B00,	0x34,		0x4B00},
{	0x4C00,	0x35,	0,	0,	0x35,	0x4C00,	0x35,		0x4C00},
{	0x4D00,	0x36,	0x7400,	0,	0x36,	0x4D00,	0x36,		0x4D00},
{	0x2B,	0x2B,	0,	0,	0x2B,	0x2B,	0x2B,		0x2B},
{	0x4F00,	0x31,	0x7500,	0,	0x31,	0x4F00,	0x31,		0x4F00},
{	0x5000,	0x32,	0,	0,	0x32,	0x5000,	0x32,		0x5000},
{	0x5100,	0x33,	0x7600,	0,	0x33,	0x5100,	0x33,		0x5100},
{	0x5200,	0x30,	0,	0,	0x30,	0x5200,	0x30,		0x5200},
{	0x5300,	0x2E,	0,	0,	0x2E,	0x5300,	0x2E,		0x5300}
};  

int i=0;

int isr30() {
// # 1.002 
	int wait_isr30=0;
        int loop=100; 

	__asm__(""
	: "=a"  (wait_isr30)); 
//   if ( wait_isr30&& !p_buffer ) return 0;
/*	/* Om ax inte är 0 ska vi vänta på ett tanget tryck */
/*	if ( wait_isr30==0 && p_buffer==0 ) asm ("movl $0, %eax\n
						  iret\n");

	else */
// # 1.002 
        if ( wait_isr30 )
	while( p_buffer == 0 );			// Wait until the buffer contains a key 
        else {
           int i;
           buffer[0]=0;
           for(i=0;i< 1000;i++);
        }
	unsigned int ret = buffer[0];		// Get ascii code from buffer

	for (i=0;i<BUFFER_SIZE;i++) 		// Move the buffer data one step forward
	  buffer[i]=buffer[i+1];	
	
//	if ( p_buffer>0 )
  	   p_buffer--;				// Decrease the pointers value one step
	if ( p_buffer>BUFFER_SIZE || p_buffer<0)		// If the buffer pointer points to a noumber higher than the buffersize the pointer is 0
	   p_buffer =0;

	return ret;
}

extern void keyboardhandler();		// Asm code that is called on with an interrupt

asm (
   ".globl _keyboardhandler \n"
   "_keyboardhandler:       \n"
   "   pusha               \n" /* Save all registers               */
   "   pushw %ds           \n" /* Set up the data segment          */
   "   pushw %es           \n"
   "   pushw %ss           \n" /* Note that ss is always valid     */
   "   pushw %ss           \n"
   "   popw %ds            \n"
   "   popw %es            \n"
   "                       \n"
   "   call _keyhandler    \n"
   "                       \n"
   "   popw %es            \n"
   "   popw %ds            \n" /* Restore registers                */
   "   popa                \n"
   "   iret                \n" /* Exit interrupt                   */
);

unsigned int key_test;		// The key_code first scancode then ascii

void keyhandler(void) {

// # 1.002 
//   unsigned int testar;
   unsigned char key_ascii;

   /*testar =*/ key_test=inportb(KEYB_PORT);	// Get scancode from keyboard port
// # 1.002 

   /* Find out if any function/control keys are pressed or released */
   if(key_test == 0x1D && !(control_keys & KEY_CTRL))	/* Ctrl key */
      control_keys |= KEY_CTRL;
   if(key_test == 0x80 + 0x1D)	/* Ctrl key depressed */
      control_keys &= (0xFF - KEY_CTRL);
   if((key_test == 0x2A || key_test == 0x36) && !(control_keys & KEY_SHIFT))	/* Shift key */
      control_keys |= KEY_SHIFT;
   if((key_test == 0x80 + 0x2A) || (key_test == 0x80 + 0x36))	/* Shift key depressed */
      control_keys &= (0xFF - KEY_SHIFT);
   if(key_test == 0x38 && (!control_keys & KEY_ALT))
      control_keys |= KEY_ALT;
   if(key_test == 0x80 + 0x38)
      control_keys &= (0xFF - KEY_ALT);

   /* Get the correct ascii code - which depends on what control keys pressed */
   if(control_keys & KEY_SHIFT) key_ascii = scan2ascii_table[key_test][1];
   else if(control_keys & KEY_CTRL) key_ascii = scan2ascii_table[key_test][2];
   else if(control_keys & KEY_ALT) key_ascii = scan2ascii_table[key_test][3];	
   else key_ascii = scan2ascii_table[key_test][0];
//   else key_test=0;

   /* If the buffer is not full and the asci code is not zero add i to the buffer */
   if ( p_buffer<BUFFER_SIZE && (key_test&0x80)==0x0 )  {
      /* add to buffer and point to the next position in buffer */
      buffer[p_buffer++]=key_ascii;
   }

   outportb(MPIC,EOI);	/* End Of IRQ */
}

void keyboard_init() {
   /* No buffer */
   p_buffer=0;
   /* Set up the interrupt descriptor */
// # 1.001
   setidt( keyboardhandler, /*0x21*/ MVEC,TRAP_GATE|BITS32, PRESENT,0);
   setidt( keyboardhandler, /*0x21*/ MVEC+1,TRAP_GATE|BITS32, PRESENT,0);
// # 1.001
   /* Enable Interrupt Requests on ch 1 */
   enable_irq(1);
   /* Set up interrupt descriptor for int 0x30 -> getch, kbhit */
   setidt( isr30, KEYISR,TRAP_GATE|BITS32, PRESENT,0);
   puts("\eGKeyboard..ok\n");
   puts("\en");

}




